import glfw
from OpenGL.GL import *
from OpenGL.GLU import *  # Добавлен недостающий импорт
from OpenGL.GL.shaders import compileProgram, compileShader
import math
from PIL import Image

# Глобальные переменные
angle_x, angle_y, angle_z = 0.0, 0.0, 0.0
size = 1.0
wireframe = False
sectors, stacks = 20, 20
light_enabled = True
texture_enabled = True
attenuation_enabled = True
position = [0.0, 0.0, 0.0]
velocity = [0.003, 0.005, 0.002]  # Скорость уменьшена в 10 раз
box_size = 4.0
vao_sphere = None
sphere_index_count = 0
shader_program = None
texture_id = 0

# Вершинный шейдер
vertex_shader_source = """
#version 120
varying vec3 v_normal;
varying vec3 v_frag_pos;
varying vec2 v_texcoord;

void main() {
    v_normal = normalize(gl_NormalMatrix * gl_Normal);
    v_frag_pos = vec3(gl_ModelViewMatrix * gl_Vertex);
    v_texcoord = gl_MultiTexCoord0.xy;
    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;
}
"""

# Фрагментный шейдер с диффузным освещением
fragment_shader_source = """
#version 120
uniform bool use_lighting;
uniform bool use_texture;
uniform bool use_attenuation;
uniform sampler2D texture0;

varying vec3 v_normal;
varying vec3 v_frag_pos;
varying vec2 v_texcoord;

void main() {
    if (!use_lighting) {
        if (use_texture) {
            gl_FragColor = texture2D(texture0, v_texcoord);
        } else {
            gl_FragColor = vec4(0.7, 0.7, 0.7, 1.0);
        }
        return;
    }

    vec3 light_pos = vec3(4.0, 4.0, 4.0);
    vec3 light_color = vec3(1.0, 1.0, 1.0);
    vec3 ambient_color = vec3(0.2, 0.2, 0.2);

    float ka = 0.2;
    float kd = 0.7;

    vec3 norm = normalize(v_normal);
    vec3 light_dir = normalize(light_pos - v_frag_pos);
    float diff = max(dot(norm, light_dir), 0.0);

    vec3 ambient = ka * ambient_color;
    vec3 diffuse = kd * diff * light_color;

    vec3 final_color = ambient + diffuse;

    if (use_texture) {
        vec3 tex_color = texture2D(texture0, v_texcoord).rgb;
        final_color *= tex_color;
    }

    if (use_attenuation) {
        float distance = length(light_pos - v_frag_pos);
        float att = 1.0 / (1.0 + 0.2 * distance + 0.1 * distance * distance);
        final_color = ambient + att * diffuse;
    }

    gl_FragColor = vec4(final_color, 1.0);
}
"""


def main():
    global texture_id, shader_program, vao_sphere, sphere_index_count

    if not glfw.init():
        return
    window = glfw.create_window(640, 640, "Lab6", None, None)
    if not window:
        glfw.terminate()
        return
    glfw.make_context_current(window)
    glfw.set_key_callback(window, key_callback)

    glEnable(GL_DEPTH_TEST)
    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    glEnable(GL_NORMALIZE)

    # Компиляция шейдеров
    shader_program = compileProgram(
        compileShader(vertex_shader_source, GL_VERTEX_SHADER),
        compileShader(fragment_shader_source, GL_FRAGMENT_SHADER)
    )
    glUseProgram(shader_program)

    # Настройка юниформов
    glUniform1i(glGetUniformLocation(shader_program, "texture0"), 0)

    # Генерация текстуры
    texture_id = generate_checkerboard_texture()

    # Генерация VAO для сферы
    vao_sphere, sphere_index_count = create_sphere_vao(sectors, stacks)

    while not glfw.window_should_close(window):
        display(window)
        update_position()
    glfw.destroy_window(window)
    glfw.terminate()


def generate_checkerboard_texture():
    width, height = 64, 64
    texture_data = []
    for i in range(height):
        for j in range(width):
            if (i // 8 + j // 8) % 2 == 0:
                texture_data.extend([200, 200, 200])
            else:
                texture_data.extend([50, 50, 50])
    texture_bytes = bytes(texture_data)

    texture_id = glGenTextures(1)
    glBindTexture(GL_TEXTURE_2D, texture_id)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
                 GL_RGB, GL_UNSIGNED_BYTE, texture_bytes)
    return texture_id


def create_sphere_vao(sectors, stacks):
    radius = 1.0
    vertices = []
    normals = []
    texcoords = []
    indices = []

    sector_step = 2 * math.pi / sectors
    stack_step = math.pi / stacks

    for i in range(stacks + 1):
        phi = i * stack_step
        for j in range(sectors + 1):
            theta = j * sector_step
            x = radius * math.sin(phi) * math.cos(theta)
            y = radius * math.sin(phi) * math.sin(theta)
            z = radius * math.cos(phi)
            s = j / sectors
            t = i / stacks
            nx, ny, nz = x, y, z

            vertices.extend([x, y, z])
            normals.extend([nx, ny, nz])
            texcoords.extend([s, t])

    for i in range(stacks):
        k1 = i * (sectors + 1)
        k2 = k1 + sectors + 1
        for j in range(sectors):
            if i != 0:
                indices.extend([k1 + j, k1 + j + 1, k2 + j])
            if i != stacks - 1:
                indices.extend([k1 + j + 1, k2 + j + 1, k2 + j])

    vbo_vertices = glGenBuffers(1)
    glBindBuffer(GL_ARRAY_BUFFER, vbo_vertices)
    glBufferData(GL_ARRAY_BUFFER, len(vertices)*4*3, (GLfloat * len(vertices))(*vertices), GL_STATIC_DRAW)

    vbo_normals = glGenBuffers(1)
    glBindBuffer(GL_ARRAY_BUFFER, vbo_normals)
    glBufferData(GL_ARRAY_BUFFER, len(normals)*4*3, (GLfloat * len(normals))(*normals), GL_STATIC_DRAW)

    vbo_texcoords = glGenBuffers(1)
    glBindBuffer(GL_ARRAY_BUFFER, vbo_texcoords)
    glBufferData(GL_ARRAY_BUFFER, len(texcoords)*4*2, (GLfloat * len(texcoords))(*texcoords), GL_STATIC_DRAW)

    ebo = glGenBuffers(1)
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo)
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, len(indices)*4, (GLuint * len(indices))(*indices), GL_STATIC_DRAW)

    vao = glGenVertexArrays(1)
    glBindVertexArray(vao)

    glBindBuffer(GL_ARRAY_BUFFER, vbo_vertices)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
    glEnableVertexAttribArray(0)

    glBindBuffer(GL_ARRAY_BUFFER, vbo_normals)
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, None)
    glEnableVertexAttribArray(1)

    glBindBuffer(GL_ARRAY_BUFFER, vbo_texcoords)
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, None)
    glEnableVertexAttribArray(2)

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo)

    glBindVertexArray(0)

    return vao, len(indices)


def display(window):
    global shader_program, vao_sphere, sphere_index_count

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glClearColor(0.1, 0.1, 0.1, 1.0)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    aspect = 640 / 640
    gluPerspective(45, aspect, 0.1, 50.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    gluLookAt(0, 0, 8, 0, 0, 0, 0, 1, 0)

    draw_bounding_box()

    glUseProgram(shader_program)
    glUniform1i(glGetUniformLocation(shader_program, "use_lighting"), light_enabled)
    glUniform1i(glGetUniformLocation(shader_program, "use_texture"), texture_enabled)
    glUniform1i(glGetUniformLocation(shader_program, "use_attenuation"), attenuation_enabled)

    glPushMatrix()
    glTranslatef(position[0], position[1], position[2])
    glRotatef(angle_x, 1, 0, 0)
    glRotatef(angle_y, 0, 1, 0)
    glRotatef(angle_z, 0, 0, 1)
    glScalef(size, size, size)

    if wireframe:
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
    else:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)

    if texture_enabled:
        glEnable(GL_TEXTURE_2D)
        glActiveTexture(GL_TEXTURE0)
        glBindTexture(GL_TEXTURE_2D, texture_id)
    else:
        glDisable(GL_TEXTURE_2D)

    glBindVertexArray(vao_sphere)
    glDrawElements(GL_TRIANGLES, sphere_index_count, GL_UNSIGNED_INT, None)
    glBindVertexArray(0)

    glPopMatrix()
    glfw.swap_buffers(window)
    glfw.poll_events()


def draw_bounding_box():
    glColor3f(1.0, 1.0, 1.0)  # Цвет границ — белый
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
    glDisable(GL_LIGHTING)
    glDisable(GL_TEXTURE_2D)
    half_size = box_size / 2
    vertices = [
        [-half_size, -half_size, -half_size],
        [half_size, -half_size, -half_size],
        [half_size, half_size, -half_size],
        [-half_size, half_size, -half_size],
        [-half_size, -half_size, half_size],
        [half_size, -half_size, half_size],
        [half_size, half_size, half_size],
        [-half_size, half_size, half_size]
    ]
    edges = [
        (0,1), (1,2), (2,3), (3,0),
        (4,5), (5,6), (6,7), (7,4),
        (0,4), (1,5), (2,6), (3,7)
    ]
    glBegin(GL_LINES)
    for edge in edges:
        for vertex in edge:
            glVertex3fv(vertices[vertex])
    glEnd()
    glEnable(GL_LIGHTING)
    glEnable(GL_TEXTURE_2D)


def update_position():
    global position, velocity
    for i in range(3):
        position[i] += velocity[i]
    half_size = box_size / 2 - size * 1.1
    for i in range(3):
        if position[i] > half_size:
            position[i] = half_size
            velocity[i] = -velocity[i]
        elif position[i] < -half_size:
            position[i] = -half_size
            velocity[i] = -velocity[i]


def key_callback(window, key, scancode, action, mods):
    global angle_x, angle_y, angle_z, wireframe, sectors, stacks
    global light_enabled, texture_enabled, attenuation_enabled
    global position, velocity

    if action == glfw.PRESS or action == glfw.REPEAT:
        if key == glfw.KEY_X: angle_x += 5
        elif key == glfw.KEY_Y: angle_y += 5
        elif key == glfw.KEY_Z: angle_z += 5
        elif key == glfw.KEY_SPACE: wireframe = not wireframe
        elif key == glfw.KEY_UP:
            sectors += 1
            stacks += 1
        elif key == glfw.KEY_DOWN:
            sectors = max(4, sectors - 1)
            stacks = max(4, stacks - 1)
        elif key == glfw.KEY_L:
            light_enabled = not light_enabled
            print(f"Освещение: {'ВКЛ' if light_enabled else 'ВЫКЛ'}")
        elif key == glfw.KEY_T:
            texture_enabled = not texture_enabled
            print(f"Текстура: {'ВКЛ' if texture_enabled else 'ВЫКЛ'}")
        elif key == glfw.KEY_A:
            attenuation_enabled = not attenuation_enabled
            print(f"Ослабление света: {'ВКЛ' if attenuation_enabled else 'ВЫКЛ'}")
        elif key == glfw.KEY_R:
            position = [0.0, 0.0, 0.0]
            velocity = [0.003, 0.005, 0.002]  # Также обновляем при сбросе


if __name__ == "__main__":
    main()
